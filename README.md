Multimodal Code Debug Assistant is a web-based debugging tool designed to help developers understand errors more clearly and resolve them more confidently. The goal of the project is to reduce the time spent interpreting logs and stack traces by automatically extracting error information, identifying the root cause, and suggesting meaningful fixes. The application supports both individual usage and real-time collaboration, allowing multiple users to work on the same debugging session simultaneously.

The system follows a clientâ€“server architecture where the frontend and backend are clearly separated. The frontend is built using React and provides an interface for entering code, pasting error logs, annotating screenshots, and viewing analysis results. It also manages authentication state and collaboration features. Communication with the backend happens through REST APIs for analysis requests and WebSockets for real-time synchronization during collaborative sessions.

The backend is implemented using FastAPI and is responsible for the core debugging logic. It handles authentication using Google OAuth and JWTs, manages collaboration sessions, and processes incoming analysis requests. The backend maintains shared session state for collaborative debugging and broadcasts updates such as code changes, log updates, and analysis results to all connected clients in real time. It also persists error logs and recurring error patterns to a database for tracking and learning purposes.

When a user submits code and logs, the system follows a structured analysis pipeline. The backend first extracts error information using deterministic rules that handle common Python errors. The extracted error is then classified by type and severity. A confidence score is computed based on how clear and reliable the detected error and its context are. This confidence score directly influences how fixes are generated and presented to the user.

Fix generation is intentionally tiered to balance usefulness and safety. When confidence is high, the system generates a deterministic code fix that directly addresses the root cause. When confidence is moderate, the system provides likely fixes based on common patterns and past observations. When confidence is low or the error is ambiguous, the system avoids making code changes and instead provides advisory guidance. This approach prevents misleading or unsafe fixes while still helping the user move forward.

Real-time collaboration is implemented using WebSockets, allowing multiple users to view and edit the same code and logs simultaneously. Any updates made by one user are instantly propagated to all others in the session. Analysis results are also broadcast to all connected participants, enabling shared understanding and discussion during debugging. Collaboration sessions are managed server-side using unique session identifiers.

Authentication is handled using a stateless JWT-based approach, while collaboration sessions remain stateful on the server. This design keeps authentication lightweight and scalable while allowing the backend to maintain shared session data such as current code, logs, and connected clients. Environment variables are used to manage secrets and configuration, keeping sensitive information out of the codebase.

The project currently assumes Python as the primary target language and focuses on runtime and syntax errors commonly encountered during development. It also assumes that users provide relevant error logs for accurate analysis and that collaboration sessions are short-lived and managed in memory. The tool is designed primarily for learning, development, and debugging assistance rather than automated production fixes.

Overall, Agentic Debug Assistant is built to act as a supportive debugging companion rather than a black-box solution. The architecture emphasizes clarity, safety, and extensibility, making it easy to add support for additional languages, improve fix generation logic, or integrate more advanced AI models in the future. The modular design ensures that the system can evolve without major restructuring while remaining understandable and maintainable.
